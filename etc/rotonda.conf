# Rotonda configuration file.
#
# Tip: Jump to the end to see a sample configuration.
#
# This file is structured as follows:
#
#     global settings
#     1 or more units
#     1 or more targets
#
# Collectively units and targets are referred to as components.
#
# Data flows downstream from at least one input unit, through zero or more
# intermediate units and out via at least one direct target.
#
# Rotonda also offers a HTTP interface which may be used to inspect the
# application state and depending on the configured units and targets may
# provide additional functionality.
#
# Taken together one can think of the flow of information like so:
#
#                                   North
#                                 (HTTP API)
#                                    ^ |
#                                    | |
#                                    | v
#        West (BGP/BMP inputs) --> pipeline --> East (BGP/BMP outputs)
#                                    ^ |
#                                    | |
#                                    | v
#                              (other outputs)
#                                   South
#
# Note: Data can only be successfully passed from one component to another if
# the receiving component supports the value type output by the producing
# component. Consult the "Pipeline interaction" sections in the documentation
# below to ensure that your chosen inputs and outputs are compatible with each
# other.
#
# Note: In the documentation below the abbreviation RT denotes a Roto Type.
#
# Note: The output stream Roto type which may be produced by Roto scripts is a
# record structure consisting of key/value pairs in which two keys have
# special meaning to Rotonda:
#
#   - name:  This key should have a string value which identifies the name of
#            the target which is intended to handle the output Roto value. That
#            target must still receive the value.
#   - topic: This key should have a string value which may be used by a target
#            that processes the output Roto value to determine what to do with
#            it, e.g. in the case of the MQTT target it can be used to
#            influence the eponymous MQTT topic to which a message will be
#            published.
#






### Logging ##################################################################

log_level = "info"         # "error", "warn", "info", "debug" or "trace"
log_target = "stderr"      # "stderr", "file" or "syslog"
log_facility = "daemon"    # used if log_target is "syslog"
log_file = "./rotonda.log" # used if log_target is "file"




### HTTP API #################################################################
#
# The HTTP API offers endpoints for interacting with and monitoring Rotonda at
# runtime:
#
#     Endpoint               Description
#     ========================================================================
#     /metrics             - Prometheus [1] metrics for monitoring Rotonda.
#                            See also the supplied example Grafana [2]
#                            dashboard file (`grafana-dashboard.json`).
#
#     /status              - Human readable application status information
#
#     /<other>             - Some components (see below) offer their own HTTP
#                            API endpoints.
#
# [1]: https://prometheus.io/docs/introduction/overview/
# [2]: https://prometheus.io/docs/visualization/grafana/
#
# The following MANDATORY settings MUST be specified:
#
#     Setting                Description
#     ========================================================================
#     http_listen            The "<IP ADDRESS>:<PORT>" to listen on for 
#                            incoming HTTP requests.
#
# The following OPTIONAL settings MAY be specified if desired:
#
#     response_compression   Whether or not to GZIP compress responses if the
#     (def: true)            client expresses support for it (via the HTTP
#                            "Accept-Encoding: gzip" request header). Set to
#                            false to completely disable GZIP response
#                            compression.




### Detailed information about the available components ######################
#
# A unit is an input or intermediate processing stage. A target is a final
# output stage. There must always be at least one unit with one downstream
# target.
#
# Unit and target definitions have similar forms:
#
#     [units.<name>]                          [targets.<name>]
#     type = "<type>"                         type = "<type>"
#     ...                                     ...
#
# Names must be unique, types must be valid and any mandatory settings
# specific to the component type must be specified.
#
# The currently available components are intended to be used like so:
#
#   bmp-tcp-in -> [filter] -> bmp-in -> rib -> mqtt-out
#
# (where [] denotes that the filter is optional)
#
# Additionally there are some components intended for diagnostic use:
#
#   bmp-tcp-out, bmp-fs-out and null-out
#
# Each unit is able to process certain types of input and emit certain types
# of output. More information about each component type is given below.




### Unit: bmp-tcp-in #########################################################
#
# This unit listens on a specified IP address and port number for incoming TCP
# connections from zero or more BMP capable routers. This unit and the
# "bmp-in" unit together implement an RFC 7854 "BGP Monitoring Protocol (BMP)"
# [1] "monitoring station".
# 
# The output of this unit should can be passed through a "filter" unit, passed
# on without further processing (e.g. logged to disk using the "bmp-fs-out"
# unit or proxied to another computer using the "bmp-tcp-out" unit), or passed
# to the "bmp-in" unit for further processing.
#
# --- Settings ---------------------------------------------------------------
#
# The following MANDATORY settings MUST be specified:
#
#     Setting                Description
#     ========================================================================
#     listen                 The "<IP ADDRESS>:<PORT>" to listen on for
#                            incoming BMP connections from routers.
#
# --- Pipeline interaction ---------------------------------------------------
#
#                              +------------+
#                              | bmp-tcp-in | --> BmpMessage (RT)
#                              +------------+



### Unit: filter #############################################################
#
# This unit runs a filter script that can be either a filter or a filter-map:
#
#   - A filter accepts or rejects the input Roto value that it receives.
#   - A filter-map does the same but the output Roto value can be different
#     than the input value, i.e. as if the input was "mapped" to the output.
#   - Both filter and filter-map scripts can optionally emit additional Roto
#     values for consumption by particular targets.
#
# --- Settings ---------------------------------------------------------------
#
# The following MANDATORY settings MUST be specified:
#
#     Setting                Description
#     ========================================================================
#     sources                An ["array", "of", "upstream", "unit", "names"]
#                            from which data will be received.
#
#     roto_path              File system path to a Roto script file that will
#                            be executed for every BMP message received by
#                            this unit. If the script terminates with "reject"
#                            the BMP message will be dropped. The script
#                            receives a BmpMessage type as input.
#
# --- Pipeline interaction ---------------------------------------------------
#
#                                +--------+
#                         RT --> | filter | --> Accept with RT, or Reject
#                                +--------+
#                                     |
#                                     |
#                                     v
#                         0..N output streams each
#                      emitting values of a single RT



### Unit: bmp-in #############################################################
#
# This unit processes incoming raw BMP messages through a BMP state machine in
# order to extract, store and propagate downstream the route announcements and
# withdrawals.
#
# This unit extends the HTTP API with endpoints that output HTML and text
# formatted information about the monitored routers currently streaming data
# into Rotonda. These endpoints are intended for operators as a diagnostic aid
# and not for automation purposes. The output format is not intended to be
# machine readable and may change without warning.
#
# --- Settings ---------------------------------------------------------------
#
# The following MANDATORY settings MUST be specified:
#
#     Setting                Description
#     ========================================================================
#     sources                An ["array", "of", "upstream", "unit", "names"]
#                            from which data will be received.
#
# The following OPTIONAL settings MAY be specified if desired:
#
#     Setting                Description
#     ========================================================================
#     http_api_path          The relative URL prefix for HTTP REST API calls
#     (def: /routers/)       responded to by this instance of this unit.
#
#     router_id_template     A user defined "<string>" that is used to name
#     (def: {sys_name})      incoming router connections according to a user
#                            supplied template which may include the following
#                            placeholders which will be expanded into their
#                            respective values for the monitored router.
#
#                                {sys_name}    - Router RFC 7854 sysName.
#                                {router_ip}   - Router source IP address.
#                                {router_port} - Router source port.
#
#                            Note: {sys_name} will be "unknown" until the
#                            sysName information TLV is received from the
#                            router as part of the BMP Initiation Message that
#                            it is required to send before any other messages.
#
# [1]: https://www.rfc-editor.org/rfc/rfc7854.html
# [2]: https://docs.rs/chrono/latest/chrono/format/strftime/index.html
#
# --- HTTP API ---------------------------------------------------------------
#
# REQUESTS:
#
#     GET /routers/
#     GET /routers/<ROUTER ID>
#
# DESCRIPTION:
#
#     This endpoint outputs information about the specified router if it is
#     currently connected to the unit.
#
# PARAMETERS:
#
#     Parameter              Description
#     ========================================================================
#     /routers/              Base path. Use the <http_api_path> unit setting
#                            to change this if using multiple instances of
#                            this unit.
#
#     <ROUTER ID>            The id of the router to query information about.
#                            Three different forms of router ID are supported:
#
#                             - <SOURCE IP>:<SOURCE PORT>, OR
#                             - <sysName>, OR
#                             - <populated router_id_template>
#
# RESPONSE: GET /routers/
#
#     A HTML table showing all currently monitored routers and some basic
#     information about them.
#
# RESPONSE: GET /routers/<ROUTER_ID>
#
#     A detailed plain text report about the monitored router and its
#     interactions with Rotonda.
#
# --- Pipeline interaction ---------------------------------------------------
#
#                                 HTTP API
#                                     ^ 
#                                     | 
#                                     | 
#                                +--------+
#            BmpMessage (RT) --> | bmp-in | --> N * Route (RT)
#                                +--------+
#
# One Route value is output per prefix announced or withdrawn via a BGP UPDATE
# message received as the payload of a BMP Route Monitoring message.
# Withdrawals may also be synthesized due to BMP Peer Down notification or
# loss of TCP connection to the monitored BMP router.




### Unit: rib ################################################################
#
# This unit is a general purpose prefix store but is primarily intended to map
# prefixes to the details of the routes to those prefixes and the source from
# which they were received.
#
# It offers a HTTP API for querying the set of known routes to a longest match
# to a given IP prefix address and length.
#
# Upstream announcements cause routes to be added to the store. Upstream
# withdrawals cause routes to be flagged as withdrawn in the store.
#
# --- Settings ---------------------------------------------------------------
#
# The following MANDATORY settings MUST be specified:
#
#     Setting                Description
#     ========================================================================
#     sources                An ["array", "of", "upstream", "unit", "names"]
#                            from which data will be received.
#
# The following OPTIONAL settings MAY be specified if desired:
#
#     Setting                Description
#     ========================================================================
#     http_api_path          The relative URL prefix for HTTP REST API calls
#     (def: /prefixes/)      responded to by this instance of this unit.
#
#     query_limits.more_specifics.shortest_prefix_ipv4 (def: 8)
#     query_limits.more_specifics.shortest_prefix_ipv6 (def: 19)
#                            These two settings protect against overly broad
#                            queries that require more time to lookup longest
#                            matching prefixes in the store. Queries for IPv4
#                            prefixes shorter than /8 (e.g. /7), or for IPv6
#                            prefixes shorter than /19 (e.g. /18), will result
#                            in a HTTP 400 Bad Request status code.
#
#     rib_keys (def: ["PeerIp", "PeerAsn", "AsPath"])
#                            Adjust this setting to control when routes are
#                            considered to be from the same peer and thus when
#                            that peer announces a route does it update or is
#                            in addition to an existing announcement, or when
#                            that peer withdraws a route, or its routes are
#                            withdrawn because the connection to it is lost,
#                            that only announced routes whose specified key
#                            fields match those of the withdrawal will be
#                            marked as withdrawn. Incorrectly specifying the
#                            set of key fields can lead to a different set of
#                            announced routes stored in the rib than expected.
#
#     roto_path              File system paths to a single Roto script. Cannot
#     (def: None)            be used with roto_paths. Behaves the same way as
#                            roto_paths with a single path.
#
#     roto_paths             An ["array", "of", "file", "system", "paths"] to
#     (def: None)            one or more Roto scripts. If more than one path
#                            is specified, the additional path entries cause
#                            virtual RIBs to be created to the East of this
#                            unit, each subsequent virtual RIB being further
#                            to the East than the last. The input type
#                            received by each script depends on the output
#                            type of the previous script, or the upstream
#                            source of this unit for the input to the first
#                            script.
#
# --- Pipeline interaction ---------------------------------------------------
#
# In summary the flow looks like this:
#
#   RT --> filter1 --> pRIB --> filter2 --> vRIB1 --> filter2 --> vRIB2 --> ..
#
# Now lets break down the various different possible scenarios into more
# detail:
#
# 1. A single physical RIB with no Roto script filtering:
#
#                                   HTTP API
#                                     ^ |
#                                     | |
#                                     | v
#                                  +------+
#                   Route (RT) --> | pRIB | --> Route (RT)
#                                  +------+
#
#
#
# 2. A single physical RIB with a Roto script filter:
#
#                                   HTTP API
#                                     ^ |
#                                     | |
#                                     | v
#                                  +------+
# RT --> filter --> Route (RT) --> | pRIB | --> Route (RT)
#           |                      +------+
#           |
#           v         
#   0..N output streams each   
#   emitting values of a single RT
#
#
# 3. A physical RIB and a virtual RIB, each with their own Roto script filter:
#
#                                   HTTP API
#                                     ^ |
#                                     | |
#                                     | v
#                                  +------+
# RT --> filter --> Route (RT) --> | pRIB | --> Route (RT) -->+
#           |                      +------+                   |  
#           |                                                 |
#           v                                                 |
#   0..N output streams each                                  |
#   emitting values of a single RT                            |
#                                                             v
#           +<------------------------------------------------+
#           |
#           |                       HTTP API
#           |                         ^ |
#           |                         | |
#           |                         | v
#           v                      +------+
#           +--> filter --> RT --> | vRIB | --> RT
#                   |              +------+                    
#                   |
#                   v         
#           0..N output streams each   
#           emitting values of a single RT
#
#
# Some notes to be aware of:
#
#   - Queries to the HTTP API of a virtual RIB are submitted upstream to the
#     physical RIB and the results flow back down the pipeline to the
#     requesting virtual RIB and out via its HTTP API.
#
#   - The input to a physical RIB is usually a Route (RT) but can also be a
#     Record (RT) with a "prefix" key, but only Route (RT) values support the
#     notion of being "withdrawn". The entire record (all its keys and values)
#     will be added to the set of values stored at the prefix in the RIB, with
#     the rib_keys fields determining whether a new value is added to the set
#     or replaces an existing item in the set.




### Target: mqtt-out #########################################################
#
# This target publishes JSON events to an MQTT broker via a TCP connection.
#
# NOTE: The MQTT broker is not part of Rotonda, it is a separate service that
# must be deployed and operated separately to Rotonda.
#
# Tested with the EMQX MQTT broker with both the free public MQTT 5 Broker [1]
# and with the EMQX Docker image [2].
#
# This target ONLY accepts input data that:
#
#   - Was received from a configured upstream source unit.
#   - Was emitted by a Roto script output stream.
#   - Is of type Record (RT) with a "name" field whose value matches the name
#     of this instance of the mqtt-out target.
#
# So naming an instance of this unit in a Roto script output stream record is
# not sufficient to have this unit receive it, this unit must still be
# downstream of the producing unit to receive its output.
#
# The JSON event structure produced by this target is a direct serialization
# of the received Roto type as JSON, i.e. a record with a set of key/value
# pairs.
#
# [1]: https://www.emqx.com/en/mqtt/public-mqtt5-broker
# [2]: https://hub.docker.com/r/emqx/emqx
# 
# --- Settings ---------------------------------------------------------------
#
# The following MANDATORY settings MUST be specified:
#
#     Setting                Description
#     ========================================================================
#     sources                An ["array", "of", "upstream", "unit", "names"]
#                            from which data will be received.
#
#     server_host            A "string" specifying the domain name or IP
#                            address of an MQTT broker to connect to.
#
#     server_port            The integer TCP port number on which to connect
#                            to the MQTT broker. Note: Only unencrypted TCP
#                            connections are supported at present, i.e. TLS
#                            and WS are not supported.
#
# The following OPTIONAL settings MAY be specified if desired:
#
#     Setting                Description
#     ========================================================================
#     client_id              A unique name to identify the client to the
#     (def: "")              server in order to hold state about the session.
#                            If empty the server will use a clean session and
#                            assign a random name to the client. Servers are
#                            required to support names upto 23 bytes in length
#                            but may support more.
#
#     qos                    MQTT quality-of-service setting for determining
#     (def: 2)               how many times a message can be delivered:
#
#                                0 (at most once)
#                                1 (at least once)
#                                2 (exactly once)
#
#                            Higher values require more synchronization with
#                            the broker leading to lower throughput but
#                            greater reliability/correctness.
#
#     queue_size             The number of messages that can be buffered for
#     (def: 1000)            delivery to the MQTT broker.
#
#     connect_retry_secs     The number of seconds to wait before attempting
#     (def: 60)              to reconnect to the MQTT broker if the connection
#                            is lost.
#
#     publish_max_secs       The number of seconds to wait before timing out
#     (def: 5)               an attempt to publish a message to the MQTT
#                            broker.
#
#     topic_template         A "string" template that will be used to 
#     (def: "rotonda/{id}")  determine the MQTT topic to which events will be
#                            published. If present, the "{id}" placeholder
#                            will be replaced by the "topic" value in the
#                            incoming Record (RT) value. When using "{id}" an
#                            MQTT client that supports MQTT wildcards can
#                            still receive all events by subscribing to
#                            'rotonda/#' for example.
#
# [1]: https://www.iana.org/assignments/bgp-well-known-communities/bgp-well-known-communities.xhtml
# [2]: https://www.iana.org/assignments/bgp-extended-communities/bgp-extended-communities.xhtml
# [3]: https://www.rfc-editor.org/rfc/rfc8092.html#section-5
#
# --- Pipeline interaction ---------------------------------------------------
#
#                               +----------+
#               Record (RT) --> | mqtt-out | - - JSON - - > MQTT server
#                               +----------+




### Target: null-out #########################################################
#
# This target discards everything it receives.
#
# Rotonda requires that there always be at least one target. Using this target
# allows you to run Rotonda for testing purposes without any "real" targets,
# or if the only output is via Roto script output stream messages.
#
# --- Settings ---------------------------------------------------------------
#
# The following MANDATORY settings MUST be specified:
#
#     Setting                Description
#     ========================================================================
#     source                 The upstream unit from which data will be
#                            received.
#
# --- Pipeline interaction ---------------------------------------------------
#
#                               +----------+
#                        RT --> | null-out |
#                               +----------+




### Target: bmp-fs-out #######################################################
#
# This target writes raw BMP messages to files on disk, either separated per
# monitored router or merged into a single file. BMP messages can be written
# in one of three different formats:
#
#   log, raw, or pcap text
#
# The log format is a limited one line per BMP message plain text log of BMP
# messages received and some limited information about each one. This format
# is intended for gaining a quick insight into the messages being received by
# Rotonda.
#
# The raw format writes the received BMP bytes out as-is, with each BMP
# message byte sequence preceeded by a number indicating how many BMP message
# bytes follow. This format is intended for capturing messages for replay for
# testing purposes later.
#
# THe PCAP text format can be transformed by the separate text2pcap tool, and
# from there can be viewed and analyzed using a tool like WireShark.
# 
# --- Settings ---------------------------------------------------------------
#
# The following MANDATORY settings MUST be specified:
#
#     Setting                Description
#     ========================================================================
#     source                 The upstream unit from which data will be
#                            received.
#
#     path                   The path to which files will be written. If mode
#                            is "split" (the default) this setting specifies
#                            a directory (which must already exist) under
#                            which one file per router will be created.
#
#     format                 Choose one of: "log", "raw", or "pcaptext".
#
# The following OPTIONAL settings MAY be specified if desired:
#
#     Setting                Description
#     ========================================================================
#     mode                   Either "merge" or "split". In merged mode all BMP
#     (def: "split")         messages from all monitored routers are appended
#                            to the same file. In split mode separate output
#                            files will be written under an EXISTING directory
#                            specified by the "path" setting. In "merge" mode
#                            all BMP messages from all monitored routers will
#                            be written into a single file file defined by the
#                            "path" setting.
#
# --- Pipeline interaction ---------------------------------------------------
#
#                              +------------+
#          BmpMessage (RT) --> | bmp-fs-out | - - - - > Writes to disk
#                              +------------+




### Target: bmp-tcp-out ######################################################
#
# This target writes raw BMP messages over a TCP connection to a specified
# destination IP address and port number, for instance to a second instance of
# Rotonda.
# 
# --- Settings ---------------------------------------------------------------
#
# The following MANDATORY settings MUST be specified:
#
#     Setting                Description
#     ========================================================================
#     sources                An ["array", "of", "upstream", "unit", "names"]
#                            from which data will be received.
#
#     target                 A TCP IP address and port number to proxy raw BMP
#                            messages to.
#
# The following OPTIONAL settings MAY be specified if desired:
#
#     Setting                Description
#     ========================================================================
#     accept                 Zero or more "IP address" values defining routers
#     (def: [])              whose BMP messages will be proxied. If specified,
#                            ONLY the specified routers will be proxied, all
#                            others will be able to connect and send messages
#                            to Rotonda.
#
#     reject                 Zero or more "IP address" values defining routers
#     (def: [])              whose BMP messages will NOT be proxied. If
#                            specified and "accept" is NOT specified, this
#                            setting will permit all other monitored routers
#                            BMP messages to be proxied.
#
# --- Pipeline interaction ---------------------------------------------------
#
#                              +-------------+
#          BmpMessage (RT) --> | bmp-tcp-out | - - - - > Proxied via TCP/IP
#                              +-------------+




### Sample component configuration ###########################################
#
# The following is a minimal example of how to configure the Rotonda units and
# targets.
#

http_listen = ["127.0.0.1:8080"]

[units.bmp-tcp-in]
type = "bmp-tcp-in"
listen = "0.0.0.0:11019"

#[targets.logger]
#type = "bmp-fs-out"
#sources = ["bmp-in"]
#path = "bmp.log"
#mode = "merge"
#format = "log"

#[targets.proxy]
#type = "bmp-tcp-out"
#sources = ["bmp-in"]
#target = "localhost:11020"
#reject = ["127.0.0.1"]

#[targets.disk]
#type = "bmp-fs-out"
#sources = ["bmp-in"]
#path = "/tmp/fs-out" 
#format = "pcaptext"

[units.routers]
type = "bmp-in"
sources = ["bmp-tcp-in"]

[units.rib]
type = "rib"
sources = ["routers"]
roto_path = "etc/filter.roto"
query_limits.more_specifics.shortest_prefix_ipv4 = 0

# A target for testing purposes that allows you to get started without yet
# having an MQTT broker to connect to.
[targets.null]
type = "null-out"
source = "rib"

# An MQTT target that publishes to a local instance of the EMQX broker.
# See: https://www.emqx.io/ & https://hub.docker.com/r/emqx/emqx
#
# Run the broker with this command:
#
#     docker run -d --name emqx -p 1883:1883 emqx/emqx:latest
#
# When using qos=2 publication of each message must be confirmed which when
# publishing at a high rate can leave many messages at the broker pending
# publication release.
#
# With the EMQX broker the limit for how many unreleased messages the broker
# will allow can be raised by passing an additional argument to `docker run`
# like so:
#
#     docker run -e EMQX_ZONE__EXTERNAL__MAX_AWAITING_REL=10000 -d --name ...
# [targets.local-broker]
# type = "mqtt-out"
# server_host = "localhost"
# server_port = 1883
# client_id = "rotonda"
# communities = ["BLACKHOLE"]
# sources = ["rib"]
